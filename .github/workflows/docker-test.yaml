name: Docker Tests

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
  pull_request:

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  acceptance:
    strategy:
      fail-fast: false
      matrix:
        file: [Dockerfile, go.Dockerfile]
        # TODO: Use self-hosted runners when available.
        runs-on: [github-hosted-ubuntu-arm64-large, github-hosted-ubuntu-x64-large]

    name: acceptance tests (${{ matrix.runs-on }}, ${{ matrix.file }})
    runs-on: ${{ matrix.runs-on }}
    permissions:
      contents: read # clone the repository
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false

      - name: docker build
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_STEP_LOG_MAX_SIZE: -1
          BUILDKIT_STEP_LOG_MAX_SPEED: -1
          FILE: ${{ matrix.file }}
        run: docker build . -t image-renderer -f "$FILE"
      - name: go test ./tests/acceptance/...
        run: go test ./tests/acceptance/... -count=1
        env:
          TERM: linux
          IMAGE: image-renderer
          UPDATE_FIXTURES: 'true' # this will make changes, so we can see them

      - name: Tar changed files
        if: failure()
        id: tar
        run: |
          set -euo pipefail
          readarray -t files < <(git diff --name-only)
          if [ "${#files[@]}" -gt "0" ]; then
            tar cJf changed-files.tar.xz "${files[@]}"
            echo 'upload=true' >> "$GITHUB_OUTPUT"
          else
            echo "No files changed :)"
          fi
      - name: Upload changed files
        if: ${{ steps.tar.outputs.upload == 'true' && (success() || failure()) }}
        uses: actions/upload-artifact@v4
        with:
          name: changed-files-${{ matrix.file }}-${{ matrix.runs-on }}
          path: changed-files.tar.xz

  # This is the job that is actually required by rulesets.
  required-acceptance-tests:
    needs:
      - acceptance
    # always() is the best function here.
    # success() || failure() will skip this function if any need is also skipped.
    # That means conditional test suites will fail the entire requirement check.
    if: always()

    name: All acceptance tests complete
    runs-on: ubuntu-latest
    steps:
      - name: Check test suites
        shell: bash
        env:
          NEEDS: ${{ needs }}
          FAILURE_MSG: Acceptance tests failed
          SUCCESS_MSG: Acceptance tests succeeded
        run: |
          set -euo pipefail

          # Print the needs context, debugging
          echo "$NEEDS" | jq

          # Extract failures
          FAILURES="$(echo "$NEEDS" | jq 'with_entries(select(.value.result == "failure")) | map_values(.result)')"

          # Check if there are any failures
          if [ "$(echo "$FAILURES" | jq '. | length')" != "0" ]; then
            echo "❌ $FAILURE_MSG"
            echo "Failed suites:"
            echo "$FAILURES" | jq -r 'to_entries[] | "- \(.key): \(.value)"'
            echo "any-failed=true" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "✅ $SUCCESS_MSG"
