name: Docker Tests

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
  pull_request:

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  acceptance:
    strategy:
      fail-fast: false
      matrix:
        runs-on: [ubuntu-x64, ubuntu-arm64]

    name: acceptance tests (${{ matrix.runs-on }})
    runs-on: ${{ matrix.runs-on }}
    permissions:
      contents: read # clone the repository
      id-token: write # required to read secrets
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false

      - name: docker build
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_STEP_LOG_MAX_SIZE: -1
          BUILDKIT_STEP_LOG_MAX_SPEED: -1
        run: docker build . -t image-renderer

      - name: Read license
        if: ${{ github.event.repository.fork == false }}
        id: license_secret
        uses: grafana/shared-workflows/actions/get-vault-secrets@a37de51f3d713a30a9e4b21bcdfbd38170020593 # get-vault-secrets/v1
        with:
          export_env: false
          repo_secrets: |
            LICENSE_JWT=grafana-enterprise-license:license-jwt
      - name: Write license to file system
        if: ${{ github.event.repository.fork == false }}
        env:
          SECRET: ${{ fromJson(steps.license_secret.outputs.secrets).LICENSE_JWT }}
        run: |
          set -euo pipefail
          LPATH="$(mktemp --tmpdir XXXXXXXXXXXX.jwt)"
          echo "$SECRET" > "$LPATH"
          echo "LICENSE_JWT=$LPATH" >> "$GITHUB_ENV"

      - name: Enable unprivileged user namespaces
        run: |
          sudo sysctl kernel.unprivileged_userns_clone=1
          sudo sysctl kernel.apparmor_restrict_unprivileged_userns=0
      - name: go test ./tests/acceptance/...
        run: go test ./tests/acceptance/... -count=1
        env:
          TERM: linux
          IMAGE: image-renderer
          UPDATE_FIXTURES: 'true' # this will make changes, so we can see them
          REQUIRE_ACCEPTANCE: 'true' # fail if no image can be found
          REQUIRE_ENTERPRISE: ${{ github.event.repository.fork == false }}

      - name: Tar changed files
        if: failure()
        id: tar
        run: |
          set -euo pipefail
          readarray -t files < <(git diff --name-only)
          if [ "${#files[@]}" -gt "0" ]; then
            tar cJf changed-files.tar.xz "${files[@]}"
            echo 'upload=true' >> "$GITHUB_OUTPUT"
          else
            echo "No files changed :)"
          fi
      - name: Upload changed files
        if: ${{ steps.tar.outputs.upload == 'true' && (success() || failure()) }}
        uses: actions/upload-artifact@v4
        with:
          name: changed-files-${{ matrix.runs-on }}
          path: changed-files.tar.xz

  # This is the job that is actually required by rulesets.
  required-acceptance-tests:
    needs:
      - acceptance
    # always() is the best function here.
    # success() || failure() will skip this function if any need is also skipped.
    # That means conditional test suites will fail the entire requirement check.
    if: always()

    name: All acceptance tests complete
    runs-on: ubuntu-latest
    steps:
      - name: Assert no failures
        env:
          NEEDS: ${{ toJson(needs) }}
        run: exit $(echo "$NEEDS" | jq 'with_entries(select(.value.result == "failure")) | length')
